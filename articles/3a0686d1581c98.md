---
title: "発注ジョブの自動テストの作成"
emoji: "🎉"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

こんにちは、バックエンドを中心に開発をしています、野島といいます。

〜〜プロダクトの説明、発注についての説明〜〜
最近は、発注ジョブの自動テストの作成を推し進めており、その中で下記の課題がありました。

- どのようにしてジョブを実行するか
- ジョブの実行結果はどう評価するか

これらに対するアプローチを共有したいと思います。

## どのようにしてジョブを実行するか

発注ジョブはCronで定期的に実行されており、テストをしたい任意のタイミングでどのようにして発注処理を実行するか、が課題でした。
そこで、テスト用のWebAPIを作成し、これを呼び出すことでジョブを実行することにしました。

弊社はクリーンアーキテクチャを採用していることもあり、ジョブの実装は下記ふたつが分離されています。
- ビジネスロジックの実装、ジョブのユースケース
- ビジネスロジックを呼び出すための実装
  - コマンドライン引数のパース
  - DB接続等のインフラ層の初期化

テストしたいものはビジネスロジックなので、WebAPIでジョブのユースケースを公開し、これにリクエストを送信します。
そうすると、Cronで実行されているジョブと同じロジックを任意のタイミングで実行できます。
このWebAPIは、テスト用のものなので、本番環境にはデプロイしません。

#### 簡単な実装例

```go
package main

import "net/http"

func main() {
	// ...production環境用のコード...

	// ...development環境でのみデプロイされる、テスト用のコード...
	if env == Development {
		http.HandleFunc("/internal/order-job", func(w http.ResponseWriter, r *http.Request) {
			err := NewJobUsecase(
			// ...DI
			).Order()
			if err != nil {
				w.Write([]byte(err.Error()))
				return
			}
			w.Write([]byte("ok"))
			return
		})
		http.ListenAndServe(":8080", nil)
	}
}

type jobUsecaseImpl struct {
	// ...dependency
}

func (r *jobUsecaseImpl) Order() error {
	// ...発注ロジック
	return nil
}

func NewJobUsecase() JobUsecase {
	return &jobUsecaseImpl{
		// ...DI
	}
}

type JobUsecase interface {
	Order() error
}

var env = "development"
const Development = "development"

```

##### 呼び出し結果

```
$ curl http://localhost:8080/internal/order-job
ok
```

## ジョブの実行結果はどう評価するか


発注JOBは、外部サービスのAPIを実行し発注処理を依頼します。外部サービスに依存があります。
この場合テストで保証したいものは、外部サービスへの発注依頼が正しく行われているか、外部サービスとのコミュニケーションを行う際の仕様が守られているか、です。
そこで、外部API呼び出しの部分にmockを利用し、正しく引数に発注情報が設定されていること(=発注依頼がただしく行われていること)を確認します。

この考え方は。。。。単体テストの、、、本だと管理下にない依存。。。の考え方を参考にしています。


#### 簡単な実装例

[先ほど](#簡単な実装例1)実装したものの差分を載せます。
mockの実装には、[moq](https://github.com/matryer/moq)というmockを自動生成するライブラリを用いています。

```go:
package main

import (
	"encoding/json"
	"github.com/HiromasaNojima/explain-order-job-test/orderapi"
	"net/http"
)

func main() {
	// ...production環境用のコード...

	// ...development環境でのみデプロイされる、テスト用のコード...
	if env == Development {
		http.HandleFunc("/internal/order-job", func(w http.ResponseWriter, r *http.Request) {
			externalAPI := &orderapi.ExternalAPIMock{
				RequestOrderFunc: func(req orderapi.OrderInfo) error {
					return nil
				},
			}
			err := NewJobUsecase(
				// ...DI
				externalAPI,
			).Order()
			if err != nil {
				w.Write([]byte(err.Error()))
				return
			}
			// 発注用APIをリクエストした時の値を取得、レスポンスで返却し、受け取り側で意図した通りにリクエストされているか評価する。
			called := externalAPI.RequestOrderCalls()[0]
			b, err := json.Marshal(called)
			w.Write(b)
			return
		})
		http.ListenAndServe(":8080", nil)
	}
}

type jobUsecaseImpl struct {
	// ...dependency
	externalAPI orderapi.ExternalAPI
}

func (r *jobUsecaseImpl) Order() error {
	// ...発注ロジック
	req := orderapi.OrderInfo{
		ProductName: "発注したい商品の名前",
	}
	// ...発注APIの呼び出し
	err := r.externalAPI.RequestOrder(req)
	if err != nil {
		return err
	}
	return nil
}

func NewJobUsecase(externalAPI orderapi.ExternalAPI) JobUsecase {
	return &jobUsecaseImpl{
		// ...DI
		externalAPI: externalAPI,
	}
}
```

```go:外部API
package orderapi

type ExternalAPI interface {
	RequestOrder(request OrderInfo) error
}
type externalAPIImpl struct{}

type OrderInfo struct {
	// ..発注情報
	ProductName string `json:"product_name"`
}

func (r externalAPIImpl) RequestOrder(request OrderInfo) error {
	// 外部API呼び出し
	return nil
}
```

```go:外部APIのモック
// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package orderapi

import (
	"sync"
)

// Ensure, that ExternalAPIMock does implement ExternalAPI.
// If this is not the case, regenerate this file with moq.
var _ ExternalAPI = &ExternalAPIMock{}

// ExternalAPIMock is a mock implementation of ExternalAPI.
//
// 	func TestSomethingThatUsesExternalAPI(t *testing.T) {
//
// 		// make and configure a mocked ExternalAPI
// 		mockedExternalAPI := &ExternalAPIMock{
// 			RequestOrderFunc: func(request OrderInfo) error {
// 				panic("mock out the RequestOrder method")
// 			},
// 		}
//
// 		// use mockedExternalAPI in code that requires ExternalAPI
// 		// and then make assertions.
//
// 	}
type ExternalAPIMock struct {
	// RequestOrderFunc mocks the RequestOrder method.
	RequestOrderFunc func(request OrderInfo) error

	// calls tracks calls to the methods.
	calls struct {
		// RequestOrder holds details about calls to the RequestOrder method.
		RequestOrder []struct {
			// Request is the request argument value.
			Request OrderInfo
		}
	}
	lockRequestOrder sync.RWMutex
}

// RequestOrder calls RequestOrderFunc.
func (mock *ExternalAPIMock) RequestOrder(request OrderInfo) error {
	if mock.RequestOrderFunc == nil {
		panic("ExternalAPIMock.RequestOrderFunc: method is nil but ExternalAPI.RequestOrder was just called")
	}
	callInfo := struct {
		Request OrderInfo
	}{
		Request: request,
	}
	mock.lockRequestOrder.Lock()
	mock.calls.RequestOrder = append(mock.calls.RequestOrder, callInfo)
	mock.lockRequestOrder.Unlock()
	return mock.RequestOrderFunc(request)
}

// RequestOrderCalls gets all the calls that were made to RequestOrder.
// Check the length with:
//     len(mockedExternalAPI.RequestOrderCalls())
func (mock *ExternalAPIMock) RequestOrderCalls() []struct {
	Request OrderInfo
} {
	var calls []struct {
		Request OrderInfo
	}
	mock.lockRequestOrder.RLock()
	calls = mock.calls.RequestOrder
	mock.lockRequestOrder.RUnlock()
	return calls
}
```

##### 呼び出し結果

```
curl http://localhost:8080/internal/order-job
{"Request":{"product_name":"発注したい商品の名前"}}
```

発注テストを実装しているツールで、レスポンスに想定通りの値が設定されていることが確認できたらOKです。

## まとめ

発注ジョブに対する自動テストのアプローチを紹介しました。
簡単に実装を行うために、ジョブのロジックをテスト用のAPIで公開する、という手法をとりました。

他には本番環境と同じようにジョブを起動するような方法もあると思います。
しかし、これを実装するためのコストの大きさや時間的制約による都合、また、ジョブの起動/終了が正しく行われることの担保はSRE側の責務と考えて、今回のテスト範囲からは外しました。

本記事の内容がジョブの自動テスト実装する際の考え方の一助となれば幸いです。

## 参考
